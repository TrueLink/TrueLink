var AMDEvaluator, AMDReturnsNothingError, AbstractMethodError, BasicEvaluator, CJSEvaluator, ChangesInWindowError, ExportsViolationError, Loader, Logger, NoSourceError, PollutionEvaluator, RawEvaluator, ReturnPollutionError, SAFE_CHARS, ThisPollutionError, UndeclaredRequireError, XHR, waitAll, __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) {
        function ctor() {
            this.constructor = child
        }
        for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
        return ctor.prototype = parent.prototype, child.prototype = new ctor, child.__super__ = parent.prototype, child
    },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) {
        for (var i = 0, l = this.length; l > i; i++)
            if (i in this && this[i] === item) return i;
        return -1
    };
AbstractMethodError = function(_super) {
    function AbstractMethodError(name) {
        this.name = "AbstractMethodError", this.message = "Calling abstract method `" + name + "` detected."
    }
    return __extends(AbstractMethodError, _super), AbstractMethodError
}(Error), UndeclaredRequireError = function(_super) {
    function UndeclaredRequireError(self_name, require_name) {
        this.self_name = self_name, this.require_name = require_name, this.name = "UndeclaredRequireError", this.message = "Found unreserved attempt to require of `" + this.require_name + "` inside `" + this.self_name + "`"
    }
    return __extends(UndeclaredRequireError, _super), UndeclaredRequireError
}(Error), ChangesInWindowError = function(_super) {
    function ChangesInWindowError(self_name, props) {
        this.self_name = self_name, this.props = props, this.name = "ChangesInWindowError", this.message = "During `" + this.self_name + "` loading window object was polluted with: " + props
    }
    return __extends(ChangesInWindowError, _super), ChangesInWindowError
}(Error), NoSourceError = function(_super) {
    function NoSourceError(url) {
        this.url = url, this.name = "NoSourceError", this.message = "Module " + this.url + " source was not found in local database. Probably it was not loaded."
    }
    return __extends(NoSourceError, _super), NoSourceError
}(Error), ExportsViolationError = function(_super) {
    function ExportsViolationError(self_name) {
        this.self_name = self_name, this.name = "ExportsViolationError", this.message = "Modules `" + this.self_name + "` overrides own exports by replacing. `exports` != `module.exports`"
    }
    return __extends(ExportsViolationError, _super), ExportsViolationError
}(Error), ReturnPollutionError = function(_super) {
    function ReturnPollutionError(self_name, props) {
        this.self_name = self_name, this.props = props, this.name = "ReturnPollutionError", this.message = "Code of `" + this.self_name + "` contains `return` statement in module scope."
    }
    return __extends(ReturnPollutionError, _super), ReturnPollutionError
}(Error), ThisPollutionError = function(_super) {
    function ThisPollutionError(self_name, props) {
        this.self_name = self_name, this.props = props, this.name = "ThisPollutionError", this.message = "Code of `" + this.self_name + "` trying to modify host object."
    }
    return __extends(ThisPollutionError, _super), ThisPollutionError
}(Error), AMDReturnsNothingError = function(_super) {
    function AMDReturnsNothingError(self_name) {
        this.self_name = self_name, this.name = "AMDReturnsNothingError", this.message = "AMD module `" + this.self_name + "` returns nothing. Should return empty object!"
    }
    return __extends(AMDReturnsNothingError, _super), AMDReturnsNothingError
}(Error), waitAll = function(array, reduce, map) {
    var counter, items, received, results;
    items = array.concat(), results = [], received = [], counter = 0, items.forEach(function(item, index) {
        map(item, function(result) {
            var i, _i, _ref;
            for (counter++, results[index] = result, received[index] = !0, i = _i = 0, _ref = items.length - 1; _ref >= 0 ? _ref >= _i : _i >= _ref; i = _ref >= 0 ? ++_i : --_i)
                if (!received[i]) return;
            return reduce(results)
        })
    })
}, XHR = function() {
    return new XMLHttpRequest
}, BasicEvaluator = function() {
    function BasicEvaluator(options) {
        this.id = options.id, this.source = options.source, this.deps = options.dependencies, this["this"] = {}, this.window = this.get_window(), this.errors = []
    }
    return BasicEvaluator.prototype.render = function() {
        throw new AbstractMethodError("render")
    }, BasicEvaluator.prototype.run = function() {
        var code, func, result;
        return code = this.render(), func = new Function(code), result = func.call(this), this._check(result), this.errors.length > 0 ? null : this._make()
    }, BasicEvaluator.prototype.get_window = function() {
        return {
            __proto__: window
        }
    }, BasicEvaluator.prototype.get_require = function() {
        throw new AbstractMethodError("get_require")
    }, BasicEvaluator.prototype._fail = function(reason) {
        throw this.errors.push(reason), reason
    }, BasicEvaluator.prototype._check = function() {
        throw new AbstractMethodError("_check")
    }, BasicEvaluator.prototype._make = function() {
        throw new AbstractMethodError("_make")
    }, BasicEvaluator
}(), CJSEvaluator = function(_super) {
    function CJSEvaluator(options) {
        CJSEvaluator.__super__.constructor.call(this, options), this.module = {}, this.exports = {}, this.module.exports = this.exports, this.require = this.get_require()
        this.process={env:{}};
    }
    return __extends(CJSEvaluator, _super), CJSEvaluator.prototype.render = function() {
        return "return (function(module, exports, require, window, process) { \n    " + this.source + "; \n}).call(this.this, this.module, this.exports, this.require, this.window, this.process);"
    }, CJSEvaluator.prototype.get_require = function() {
        var require;
        return require = function(name) {
            var value = this.deps[name];
            //console.log(name, value != null);
            return null == value && this._fail(new UndeclaredRequireError(this.id, name)), value
        }, require.bind(this)
    }, CJSEvaluator.prototype._check = function(result) {
        var this_keys, window_keys;
        if (window_keys = Object.keys(this.window), 0 !== window_keys.length) throw new ChangesInWindowError(this.id, window_keys);
        if (this.exports !== this.module.exports && 0 !== Object.keys(this.exports).length) throw new ExportsViolationError(this.id);
        if (null != result) throw new ReturnPollutionError(this.id, Object.keys(result));
        if (this_keys = Object.keys(this["this"]), 0 !== this_keys.length) throw new ThisPollutionError(this.id, this_keys)
    }, CJSEvaluator.prototype._make = function() {
        return this.module.exports
    }, CJSEvaluator
}(BasicEvaluator), AMDEvaluator = function(_super) {
    function AMDEvaluator(options) {
        AMDEvaluator.__super__.constructor.call(this, options), this.define = this.get_define()
    }
    return __extends(AMDEvaluator, _super), AMDEvaluator.prototype.render = function() {
        return "return (function(define, window) { \n    " + this.source + "; \n}).call(this.this, this.define, this.window);"
    }, AMDEvaluator.prototype.get_define = function() {
        var define;
        return define = function(names, func) {
            var needREM;
            if(!func) {
                //console.log("no-names hack");
                func = names;
                names = [];
                needREM = true;
            }
            var deps, name;
            if(needREM){
                var m={};
                m.exports={};
                deps = [function(s){
                    //console.log("rem require ",s);
                    if(!this.deps[s]) {
                        throw new UndeclaredRequireError(this.id, s);
                    }
                    return this.deps[s];
                }.bind(this),m.exports,m];
                var rs = func.apply(this["this"], deps);
                return this.result = rs || m.exports;
            }else{
            return deps = function() {
                var _i, _len, _results;
                for (_results = [], _i = 0, _len = names.length; _len > _i; _i++) name = names[_i], _results.push(this.deps[name]);
                return _results
            }.call(this), this.result = func.apply(this["this"], deps)
            }
        }, define.bind(this)
    }, AMDEvaluator.prototype._check = function(result) {
        var this_keys, window_keys;
        if (window_keys = Object.keys(this.window), 0 !== window_keys.length) throw new ChangesInWindowError(this.id, window_keys);
        if (null != result) throw new ReturnPollutionError(this.id, Object.keys(result));
        if (this_keys = Object.keys(this["this"]), 0 !== this_keys.length) throw new ThisPollutionError(this.id, this_keys);
        if (null == this.result) throw new AMDReturnsNothingError(this.id)
    }, AMDEvaluator.prototype._make = function() {
        return this.result
    }, AMDEvaluator
}(BasicEvaluator), PollutionEvaluator = function(_super) {
    function PollutionEvaluator() {
        return PollutionEvaluator.__super__.constructor.apply(this, arguments)
    }
    return __extends(PollutionEvaluator, _super), PollutionEvaluator.prototype.render = function() {
        var args, name, names;
        return names = ["window"].concat(function() {
            var _results;
            _results = [];
            for (name in this.deps) _results.push(name);
            return _results
        }.call(this)).join(", "), args = ["this.this", "this.window"].concat(function() {
            var _results;
            _results = [];
            for (name in this.deps) _results.push('this.deps["' + name + '"]');
            return _results
        }.call(this)).join(", "), "return (function(" + names + ") {\n    " + this.source + ";\n}).call(" + args + ");"
    }, PollutionEvaluator.prototype._check = function(result) {
        if (null != result) throw new ReturnPollutionError(this.id, Object.keys(result))
    }, PollutionEvaluator.prototype.get_window = function() {
        var name, result, value, _ref;
        result = {
            __proto__: PollutionEvaluator.__super__.get_window.call(this)
        }, _ref = this.deps;
        for (name in _ref) value = _ref[name], result[name] = value;
        return {
            __proto__: result
        }
    }, PollutionEvaluator.prototype._make = function() {
        var name, result, value, _ref, _ref1;
        result = {}, _ref = this.window;
        for (name in _ref) __hasProp.call(_ref, name) && (value = _ref[name], result[name] = value);
        _ref1 = this["this"];
        for (name in _ref1) __hasProp.call(_ref1, name) && (value = _ref1[name], result[name] = value);
        return result
    }, PollutionEvaluator
}(BasicEvaluator), RawEvaluator = function(_super) {
    function RawEvaluator() {
        return RawEvaluator.__super__.constructor.apply(this, arguments)
    }
    return __extends(RawEvaluator, _super), RawEvaluator.prototype.render = function() {
        return this.source
    }, RawEvaluator.prototype._check = function() {}, RawEvaluator.prototype.get_window = function() {
        return window
    }, RawEvaluator.prototype._make = function() {
        return {}
    }, RawEvaluator
}(BasicEvaluator), SAFE_CHARS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", Logger = function() {
    function Logger(prefix) {
        this.prefix = prefix
    }
    return Logger.prototype.info = function() {
        var args;
        return args = 1 <= arguments.length ? __slice.call(arguments, 0) : [], console.info.apply(console, [this.prefix].concat(__slice.call(args)))
    }, Logger.prototype.warn = function() {
        var args;
        return args = 1 <= arguments.length ? __slice.call(arguments, 0) : [], console.warn.apply(console, [this.prefix].concat(__slice.call(args)))
    }, Logger.prototype.error = function() {
        var args;
        return args = 1 <= arguments.length ? __slice.call(arguments, 0) : [], console.error.apply(console, [this.prefix].concat(__slice.call(args)))
    }, Logger
}(), Loader = function() {
    function Loader(options) {
        var _ref, _ref1;
        this._all_modules = {}, this._current_manifest = null, this._update_started = !1, this._modules_to_load = [], this._new_manifest = null, this._total_size = 0, this._evaluators = {
            cjs: CJSEvaluator,
            amd: AMDEvaluator,
            junk: PollutionEvaluator,
            raw: RawEvaluator
        }, this.version = options.version, this.prefix = options.prefix, this.hash_name = options.hash_name, this.hash_func = options.hash_func, this.decoder_func = options.decoder_func, this.randomize_urls = options.randomize_urls, this.manifest_location = null != (_ref = options.manifest_location) ? _ref : "manifest.json", this.options = options, this.logger = null != (_ref1 = options.logger) ? _ref1 : new Logger("LOADER:" + this.prefix), this.manifest_key = this.prefix + "::manifest", localforage.config()
    }
    return Loader.prototype._prepare_url = function(url) {
        var i, result, _i;
        if (!this.randomize_urls) return escape(url);
        for (result = "", i = _i = 0; 16 >= _i; i = ++_i) result += SAFE_CHARS[Math.round(Math.random() * (SAFE_CHARS.length - 1))];
        return escape(url) + "?" + result
    }, Loader.prototype._parse_manifest = function(content) {
        var manifest, raw;
        if (null == content) throw ReferenceError("Manifest was not defined");
        if (raw = JSON.parse(content), !(raw instanceof Object)) throw TypeError("Invalid manifest format");
        if (null == raw.modules) throw TypeError("Invalid manifest format");
        if (raw.version !== this.version) throw TypeError("Invalid manifest version. Got: " + raw.version + ". Expected: " + this.version);
        if (raw.hash_func !== this.hash_name) throw TypeError("Invalid manifest hash function. Got: " + raw.hash_func + ". Expected: " + this.hash_name);
        return manifest = {
            content: content,
            modules: raw.modules,
            version: raw.version,
            hash_func: raw.hash_func,
            hash: this.hash_func(content)
        }
    }, Loader.prototype.get_manifest = function() {
        return this._parse_manifest(window.localStorage.getItem(this.manifest_key))
    }, Loader.prototype.set_manifest = function(manifest) {
        window.localStorage.setItem(this.manifest_key, manifest.content)
    }, Loader.prototype.del_manifest = function() {
        window.localStorage.removeItem(this.manifest_key)
    }, Loader.prototype.make_key = function(module) {
        return this.prefix + ":" + module.hash + ":" + module.url
    }, Loader.prototype.get_content = function(key, cb) {
        return localforage.getItem(key, cb)
    }, Loader.prototype.set_content = function(key, content, cb) {
        return this.logger.info("storing", key), localforage.setItem(key, content, cb)
    }, Loader.prototype.get_contents_keys = function(cb) {
        localforage.keys(function() {
            return function(keys) {
                var key, _i, _len;
                for (_i = 0, _len = keys.length; _len > _i; _i++) key = keys[_i], cb(key)
            }
        }(this))
    }, Loader.prototype.del_content = function(key, cb) {
        return this.logger.warn("removing", key), localforage.removeItem(key, cb)
    }, Loader.prototype.onNoManifest = function() {}, Loader.prototype.onUpToDate = function() {}, Loader.prototype.onUpdateFound = function() {
        return this.startUpdate()
    }, Loader.prototype.onUpdateFailed = function() {}, Loader.prototype.onUpdateCompleted = function() {
        return !0
    }, Loader.prototype.onModuleBeginDownload = function() {}, Loader.prototype.onModuleDownloadFailed = function() {}, Loader.prototype.onModuleDownloadProgress = function() {}, Loader.prototype.onTotalDownloadProgress = function() {}, Loader.prototype.onModuleDownloaded = function() {}, Loader.prototype.onEvaluationStarted = function() {
        return !0
    }, Loader.prototype.onEvaluationError = function() {}, Loader.prototype.onModuleEvaluated = function() {}, Loader.prototype.onApplicationReady = function() {
        return this.checkUpdate()
    }, Loader.prototype.emit = function() {
        var args, error, name, _ref;
        name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [], (_ref = this.logger).info.apply(_ref, [name].concat(__slice.call(args)));
        try {
            return this["on" + name].apply(this, args)
        } catch (_error) {
            return error = _error, this.logger.error(error)
        }
    }, Loader.prototype.load = function() {
        var error;
        try {
            this._current_manifest = this.get_manifest()
        } catch (_error) {
            return error = _error, void this.emit("NoManifest")
        }
        this.logger.info("Current manifest", this._current_manifest), this.emit("EvaluationStarted", this._current_manifest) !== !1 && (this.evaluate(this._current_manifest.modules), this._cleanUp())
    }, Loader.prototype.evaluate = function(queue) {
        var key, module;
        return queue = queue.concat(), 0 === queue.length ? void this.emit("ApplicationReady", this._current_manifest) : (module = queue.shift(), key = this.make_key(module), this.get_content(key, function(_this) {
            return function(module_source) {
                var alias, dep, deps, error, evaluator, namespace, _ref, _ref1;
                if (null == module_source) return void _this.emit("EvaluationError", module, new NoSourceError(module.url));
                try {
                    module.source = _this.decoder_func(module_source, module, _this)
                } catch (_error) {
                    return error = _error, void _this.emit("EvaluationError", module, error)
                }
                deps = {}, _ref = module.deps;
                for (alias in _ref) dep = _ref[alias], deps[alias] = _this._all_modules[dep];
                deps.loader = _this, evaluator = new _this._evaluators[null != (_ref1 = module.type) ? _ref1 : "cjs"]({
                    id: module.id,
                    source: module.source,
                    dependencies: deps
                });
                try {
                    namespace = evaluator.run()
                } catch (_error) {
                    return error = _error, void _this.emit("EvaluationError", module, error)
                }
                return _this._all_modules[module.id] = namespace, module.namespace = namespace, _this.emit("ModuleEvaluated", module), _this.evaluate(queue)
            }
        }(this)))
    }, Loader.prototype.checkUpdate = function() {
        var manifest_request;
        this._update_started || (this.logger.info("Checking for update..."), manifest_request = XHR(), manifest_request.open("GET", this._prepare_url(this.manifest_location), !0), manifest_request.overrideMimeType("application/json; charset=utf-8"), manifest_request.onload = function(_this) {
            return function(event) {
                var error;
                if (404 === event.target.status) return void _this.emit("UpdateFailed", event, null);
                try {
                    _this._new_manifest = _this._parse_manifest(event.target.response)
                } catch (_error) {
                    return error = _error, void _this.emit("UpdateFailed", event, error)
                }
                return _this.logger.info("New manifest", _this._new_manifest), null != _this._current_manifest && _this._current_manifest.hash === _this._new_manifest.hash ? void _this.emit("UpToDate", _this._current_manifest) : _this.emit("UpdateFound", event, _this._new_manifest)
            }
        }(this), manifest_request.onerror = function(_this) {
            return function(event) {
                return _this.emit("UpdateFailed", event, null)
            }
        }(this), manifest_request.onabort = function(_this) {
            return function(event) {
                return _this.emit("UpdateFailed", event, null)
            }
        }(this), manifest_request.send())
    }, Loader.prototype.startUpdate = function() {
        var module, _i, _j, _len, _len1, _ref, _ref1;
        for (this.logger.info("Starting update..."), this._update_started = !0, _ref = this._new_manifest.modules, _i = 0, _len = _ref.length; _len > _i; _i++) module = _ref[_i], module.loaded = 0;
        for (this._modules_to_load = this._new_manifest.modules.concat(), _ref1 = this._modules_to_load.splice(0, 4), _j = 0, _len1 = _ref1.length; _len1 > _j; _j++) module = _ref1[_j], this._updateModule(module)
    }, Loader.prototype.dropData = function() {
        return this.del_manifest()
    }, Loader.prototype._updateModule = function(module) {
        var key;
        key = this.make_key(module), this.get_content(key, function(_this) {
            return function(module_source) {
                if (null != module_source) {
                    if (_this.hash_func(module_source) !== module.hash) return void _this.emit("ModuleDownloadFailed", null, module);
                    module.source = module_source, module.loaded = module.size, _this.emit("ModuleDownloaded", module), _this._reportTotalProgress(), _this._checkAllUpdated()
                } else _this._downloadModule(module)
            }
        }(this))
    }, Loader.prototype._reportTotalProgress = function() {
        var loaded_count, loaded_size, module, progress, total_count, total_size, _i, _len, _ref;
        for (loaded_size = 0, total_size = 0, loaded_count = 0, total_count = 0, _ref = this._new_manifest.modules, _i = 0, _len = _ref.length; _len > _i; _i++) module = _ref[_i], total_size += module.size, loaded_size += module.loaded, total_count++, null != module.source && loaded_count++;
        return progress = {
            loaded_count: loaded_count,
            total_count: total_count,
            loaded_size: loaded_size,
            total_size: total_size
        }, this.emit("TotalDownloadProgress", progress)
    }, Loader.prototype._downloadModule = function(module) {
        var module_request;
        this.emit("ModuleBeginDownload", module), module_request = XHR(), module_request.open("GET", this._prepare_url(module.url), !0), module_request.responseType = "arraybuffer", module_request.onload = function(_this) {
            return function(event) {
                var module_source;
                return module_source = event.target.response, _this.hash_func(module_source) !== module.hash ? void _this.emit("ModuleDownloadFailed", event, module) : _this.set_content(_this.make_key(module), module_source, function() {
                    return module.source = module_source, module.loaded = module.size, _this.emit("ModuleDownloaded", module), _this._reportTotalProgress(), _this._checkAllUpdated()
                })
            }
        }(this), module_request.onprogress = function(_this) {
            return function(event) {
                return module.loaded = event.loaded, _this.emit("ModuleDownloadProgress", event, module), _this._reportTotalProgress()
            }
        }(this), module_request.onerror = function(_this) {
            return function(event) {
                return _this.emit("ModuleDownloadFailed", event, module)
            }
        }(this), module_request.onabort = function(_this) {
            return function(event) {
                return _this.emit("ModuleDownloadFailed", event, module)
            }
        }(this), module_request.send()
    }, Loader.prototype._checkAllUpdated = function() {
        var module, next, _i, _len, _ref;
        if (next = this._modules_to_load.shift(), null != next) return void this._updateModule(next);
        for (_ref = this._new_manifest.modules, _i = 0, _len = _ref.length; _len > _i; _i++)
            if (module = _ref[_i], null == module.source) return;
        this.emit("UpdateCompleted", this._new_manifest) && (this.set_manifest(this._new_manifest), this._current_manifest = this._new_manifest, this._new_manifest = null), this._update_started = !1
    }, Loader.prototype._cleanUp = function() {
        var module, useful;
        useful = function() {
            var _i, _len, _ref, _results;
            for (_ref = this._current_manifest.modules, _results = [], _i = 0, _len = _ref.length; _len > _i; _i++) module = _ref[_i], _results.push(this.make_key(module));
            return _results
        }.call(this), useful.push(this.manifest_key), this.get_contents_keys(function(_this) {
            return function(key) {
                null != key && 0 === key.indexOf(_this.prefix) && (__indexOf.call(useful, key) >= 0 || _this.del_content(key))
            }
        }(this))
    }, Loader
}();
